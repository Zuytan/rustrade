use crate::domain::types::{Order, OrderSide, TradeProposal};
use rust_decimal::Decimal;

/// Trading events for observability and monitoring
#[derive(Debug, Clone)]
pub enum TradingEvent {
    /// Signal generated by strategy
    SignalGenerated {
        symbol: String,
        side: OrderSide,
        price: Decimal,
        reason: String,
        timestamp: i64,
    },
    
    /// Trade proposal created by Analyst
    TradeProposed {
        proposal: TradeProposal,
    },
    
    /// Trade approved by Risk Manager
    TradeApproved {
        symbol: String,
        side: OrderSide,
        quantity: Decimal,
        reason: String,
    },
    
    /// Trade rejected by Risk Manager
    TradeRejected {
        symbol: String,
        side: OrderSide,
        quantity: Decimal,
        reason: String,
    },
    
    /// Order executed on exchange
    OrderExecuted {
        order: Order,
        fill_price: Decimal,
    },
    
    /// Trailing stop triggered
    TrailingStopTriggered {
        symbol: String,
        entry_price: Decimal,
        stop_price: Decimal,
        current_price: Decimal,
    },
    
    /// Portfolio updated
    PortfolioUpdated {
        equity: Decimal,
        cash: Decimal,
        positions_count: usize,
    },
    
    /// Circuit breaker activated
    CircuitBreakerActivated {
        reason: String,
        cooldown_seconds: u64,
    },
}

/// Event listener trait for Observer pattern
pub trait EventListener: Send + Sync {
    fn on_event(&self, event: &TradingEvent);
}

/// Logging implementation of EventListener
pub struct LoggingListener;

impl EventListener for LoggingListener {
    fn on_event(&self, event: &TradingEvent) {
        use tracing::{info, warn};
        
        match event {
            TradingEvent::SignalGenerated { symbol, side, price, reason, .. } => {
                info!("ðŸ“Š Signal: {:?} {} @ ${} - {}", side, symbol, price, reason);
            }
            TradingEvent::TradeProposed { proposal } => {
                info!("ðŸ’¡ Proposal: {:?} {} x{} @ ${}", 
                    proposal.side, proposal.symbol, proposal.quantity, proposal.price);
            }
            TradingEvent::TradeApproved { symbol, side, quantity, reason } => {
                info!("âœ… Approved: {:?} {} x{} - {}", side, symbol, quantity, reason);
            }
            TradingEvent::TradeRejected { symbol, side, quantity, reason } => {
                warn!("âŒ Rejected: {:?} {} x{} - {}", side, symbol, quantity, reason);
            }
            TradingEvent::OrderExecuted { order, fill_price } => {
                info!("ðŸŽ¯ Executed: {:?} {} x{} @ ${} (fill: ${})", 
                    order.side, order.symbol, order.quantity, order.price, fill_price);
            }
            TradingEvent::TrailingStopTriggered { symbol, entry_price, stop_price, current_price } => {
                info!("ðŸ›‘ Trailing Stop: {} triggered at ${} (entry: ${}, stop: ${})",
                    symbol, current_price, entry_price, stop_price);
            }
            TradingEvent::PortfolioUpdated { equity, cash, positions_count } => {
                info!("ðŸ’° Portfolio: Equity=${}, Cash=${}, Positions={}",
                    equity, cash, positions_count);
            }
            TradingEvent::CircuitBreakerActivated { reason, cooldown_seconds } => {
                warn!("ðŸš¨ Circuit Breaker: {} (cooldown: {}s)", reason, cooldown_seconds);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;
    
    #[test]
    fn test_logging_listener_signal_generated() {
        let listener = LoggingListener;
        let event = TradingEvent::SignalGenerated {
            symbol: "AAPL".to_string(),
            side: OrderSide::Buy,
            price: dec!(150.0),
            reason: "Golden Cross".to_string(),
            timestamp: 1234567890,
        };
        
        // Should not panic
        listener.on_event(&event);
    }
    
    #[test]
    fn test_logging_listener_all_events() {
        let listener = LoggingListener;
        
        let events = vec![
            TradingEvent::TradeApproved {
                symbol: "AAPL".to_string(),
                side: OrderSide::Buy,
                quantity: dec!(10),
                reason: "Risk OK".to_string(),
            },
            TradingEvent::TradeRejected {
                symbol: "NVDA".to_string(),
                side: OrderSide::Sell,
                quantity: dec!(5),
                reason: "Max position".to_string(),
            },
            TradingEvent::CircuitBreakerActivated {
                reason: "Daily loss limit".to_string(),
                cooldown_seconds: 3600,
            },
        ];
        
        for event in events {
            listener.on_event(&event);
        }
    }
}
