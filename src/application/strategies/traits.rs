use crate::domain::market::order_flow::VolumeProfile;
use crate::domain::market::timeframe::Timeframe;
use crate::domain::trading::types::{Candle, OrderSide};
use rust_decimal::Decimal;
use std::collections::{HashMap, VecDeque};

/// Features for a specific timeframe
#[derive(Debug, Clone)]
pub struct TimeframeFeatures {
    pub timeframe: Timeframe,
    pub fast_sma: Option<f64>,
    pub slow_sma: Option<f64>,
    pub trend_sma: Option<f64>,
    pub rsi: Option<f64>,
    pub macd_histogram: Option<f64>,
    pub adx: Option<f64>,
    pub price: Option<f64>,
}

/// Context provided to trading strategies for analysis
#[derive(Debug, Clone)]
pub struct AnalysisContext {
    pub symbol: String,
    pub current_price: Decimal,
    pub price_f64: f64,

    // SMA state (primary timeframe)
    pub fast_sma: f64,
    pub slow_sma: f64,
    pub trend_sma: f64,

    // Technical indicators (primary timeframe)
    pub rsi: f64,
    pub macd_value: f64,
    pub macd_signal: f64,
    pub macd_histogram: f64,
    pub last_macd_histogram: Option<f64>,
    pub atr: f64,
    pub bb_lower: f64,
    pub bb_upper: f64,
    pub bb_middle: f64,
    pub adx: f64,

    // Position state
    pub has_position: bool,

    // Timestamp
    pub timestamp: i64,

    // Candle history (for SMC patterns)
    pub candles: VecDeque<Candle>,

    // Historical Indicators (for Momentum/Divergence)
    pub rsi_history: VecDeque<f64>,

    // Order Flow Imbalance (OFI) - Microstructure Analysis
    /// Current Order Flow Imbalance value (-1.0 to +1.0)
    /// Positive values indicate buying pressure, negative indicate selling pressure
    pub ofi_value: f64,
    /// Cumulative Delta - running sum of order flow imbalances
    pub cumulative_delta: f64,
    /// Volume Profile - distribution of volume by price level
    pub volume_profile: Option<VolumeProfile>,
    /// Historical OFI values for divergence detection (last 20 values)
    pub ofi_history: VecDeque<f64>,

    // Advanced Statistical Features (Phase 2)
    /// Hurst Exponent (0-1): H>0.5 = trending, H<0.5 = mean-reverting
    pub hurst_exponent: Option<f64>,
    /// Skewness: distribution asymmetry (positive = right tail, negative = left tail)
    pub skewness: Option<f64>,
    /// ATR-normalized momentum: (Price - Price_N) / ATR
    pub momentum_normalized: Option<f64>,
    /// Realized volatility: annualized rolling volatility
    pub realized_volatility: Option<f64>,

    // Multi-timeframe data (optional for backward compatibility)
    pub timeframe_features: Option<HashMap<Timeframe, TimeframeFeatures>>,

    // Raw Feature Set (for ML and complex Analysis)
    pub feature_set: Option<crate::domain::trading::types::FeatureSet>,
}

/// Signal generated by a trading strategy
#[derive(Debug, Clone)]
pub struct Signal {
    pub side: OrderSide,
    pub reason: String,
    pub confidence: f64, // 0.0 to 1.0
}

impl Signal {
    pub fn buy(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Buy,
            reason: reason.into(),
            confidence: 1.0,
        }
    }

    pub fn sell(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Sell,
            reason: reason.into(),
            confidence: 1.0,
        }
    }

    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }
}

impl AnalysisContext {
    /// Check if a higher timeframe confirms the trend direction
    ///
    /// Returns true if the specified higher timeframe shows a trend aligned with the signal
    pub fn higher_timeframe_confirms_trend(&self, side: OrderSide, higher_tf: Timeframe) -> bool {
        let Some(ref tf_features) = self.timeframe_features else {
            // No multi-timeframe data available, default to true (backward compatible)
            return true;
        };

        let Some(features) = tf_features.get(&higher_tf) else {
            // Requested timeframe not available, default to true
            return true;
        };

        // Check if price is above/below trend SMA on higher timeframe
        match side {
            OrderSide::Buy => {
                // For buy signals, higher timeframe should be bullish (price > trend_sma)
                if let (Some(price), Some(trend_sma)) = (features.price, features.trend_sma) {
                    price > trend_sma
                } else {
                    true // Missing data, don't block
                }
            }
            OrderSide::Sell => {
                // For sell signals, we're more permissive
                true
            }
        }
    }

    /// Calculate multi-timeframe trend strength (0.0 to 1.0)
    ///
    /// Returns the percentage of timeframes showing bullish trend
    pub fn multi_timeframe_trend_strength(&self) -> f64 {
        let Some(ref tf_features) = self.timeframe_features else {
            // No multi-timeframe data, use primary timeframe
            return if self.price_f64 > self.trend_sma {
                1.0
            } else {
                0.0
            };
        };

        if tf_features.is_empty() {
            return if self.price_f64 > self.trend_sma {
                1.0
            } else {
                0.0
            };
        }

        let mut bullish_count = 0;
        let mut total_count = 0;

        // Check primary timeframe
        if self.price_f64 > self.trend_sma {
            bullish_count += 1;
        }
        total_count += 1;

        // Check each higher timeframe
        for features in tf_features.values() {
            if let (Some(price), Some(trend_sma)) = (features.price, features.trend_sma) {
                if price > trend_sma {
                    bullish_count += 1;
                }
                total_count += 1;
            }
        }

        bullish_count as f64 / total_count as f64
    }

    /// Check if all enabled timeframes show bullish trend
    pub fn all_timeframes_bullish(&self) -> bool {
        self.multi_timeframe_trend_strength() >= 1.0
    }

    /// Get ADX from highest available timeframe for regime detection
    pub fn get_highest_timeframe_adx(&self) -> f64 {
        let Some(ref tf_features) = self.timeframe_features else {
            return self.adx;
        };

        // Try to get ADX from highest timeframe (1Day > 4Hour > 1Hour > ...)
        for tf in [
            Timeframe::OneDay,
            Timeframe::FourHour,
            Timeframe::OneHour,
            Timeframe::FifteenMin,
        ] {
            if let Some(features) = tf_features.get(&tf)
                && let Some(adx) = features.adx
            {
                return adx;
            }
        }

        // Fall back to primary timeframe
        self.adx
    }
}

/// Trading strategy trait for the Strategy Pattern
pub trait TradingStrategy: Send + Sync {
    /// Analyze market context and potentially generate a trading signal
    fn analyze(&self, ctx: &AnalysisContext) -> Option<Signal>;

    /// Strategy name for logging and identification
    fn name(&self) -> &str;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_creation() {
        let buy_signal = Signal::buy("Test reason");
        assert!(matches!(buy_signal.side, OrderSide::Buy));
        assert_eq!(buy_signal.confidence, 1.0);

        let sell_signal = Signal::sell("Another reason").with_confidence(0.8);
        assert!(matches!(sell_signal.side, OrderSide::Sell));
        assert_eq!(sell_signal.confidence, 0.8);
    }

    #[test]
    fn test_confidence_clamping() {
        let signal = Signal::buy("Test").with_confidence(1.5);
        assert_eq!(signal.confidence, 1.0);

        let signal2 = Signal::sell("Test").with_confidence(-0.5);
        assert_eq!(signal2.confidence, 0.0);
    }
}
