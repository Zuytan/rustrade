use crate::domain::market::order_flow::VolumeProfile;
use crate::domain::market::timeframe::Timeframe;
use crate::domain::trading::types::{Candle, OrderSide};
use rust_decimal::Decimal;
use rust_decimal::prelude::FromPrimitive;

use std::collections::{HashMap, VecDeque};

/// Features for a specific timeframe
#[derive(Debug, Clone)]
pub struct TimeframeFeatures {
    pub timeframe: Timeframe,
    pub fast_sma: Option<Decimal>,
    pub slow_sma: Option<Decimal>,
    pub trend_sma: Option<Decimal>,
    pub rsi: Option<Decimal>,
    pub macd_histogram: Option<Decimal>,
    pub adx: Option<Decimal>,
    pub price: Option<Decimal>,
}

/// Position information for position-aware strategies
#[derive(Debug, Clone, Default)]
pub struct PositionInfo {
    /// Average entry price
    pub entry_price: Decimal,
    /// Current position quantity
    pub quantity: Decimal,
    /// Unrealized P&L as percentage (e.g., 0.05 = +5%)
    pub unrealized_pnl_pct: Decimal,
}

/// Context provided to trading strategies for analysis
#[derive(Debug, Clone)]
pub struct AnalysisContext {
    pub symbol: String,
    pub current_price: Decimal,
    pub price_f64: f64,

    // SMA state (primary timeframe)
    pub fast_sma: Option<Decimal>,
    pub slow_sma: Option<Decimal>,
    pub trend_sma: Option<Decimal>,

    // Technical indicators (primary timeframe)
    pub rsi: Option<Decimal>,
    pub macd_value: Option<Decimal>,
    pub macd_signal: Option<Decimal>,
    pub macd_histogram: Option<Decimal>,
    pub last_macd_histogram: Option<Decimal>,
    pub atr: Option<Decimal>,
    pub bb_lower: Option<Decimal>,
    pub bb_upper: Option<Decimal>,
    pub bb_middle: Option<Decimal>,
    pub adx: Option<Decimal>,

    // Position state
    pub has_position: bool,
    /// Position details (None if no position)
    pub position: Option<PositionInfo>,

    // Timestamp
    pub timestamp: i64,

    // Candle history (for SMC patterns)
    pub candles: VecDeque<Candle>,

    // Historical Indicators (for Momentum/Divergence)
    pub rsi_history: VecDeque<Decimal>,

    // Order Flow Imbalance (OFI) - Microstructure Analysis
    /// Current Order Flow Imbalance value (-1.0 to +1.0)
    /// Positive values indicate buying pressure, negative indicate selling pressure
    pub ofi_value: Decimal,
    /// Cumulative Delta - running sum of order flow imbalances
    pub cumulative_delta: Decimal,
    /// Volume Profile - distribution of volume by price level
    pub volume_profile: Option<VolumeProfile>,
    /// Historical OFI values for divergence detection (last 20 values)
    pub ofi_history: VecDeque<Decimal>,

    // Advanced Statistical Features (Phase 2)
    /// Hurst Exponent (0-1): H>0.5 = trending, H<0.5 = mean-reverting
    pub hurst_exponent: Option<Decimal>,
    /// Skewness: distribution asymmetry (positive = right tail, negative = left tail)
    pub skewness: Option<Decimal>,
    /// ATR-normalized momentum: (Price - Price_N) / ATR
    pub momentum_normalized: Option<Decimal>,
    /// Realized volatility: annualized rolling volatility
    pub realized_volatility: Option<Decimal>,

    // Multi-timeframe data (optional for backward compatibility)
    pub timeframe_features: Option<HashMap<Timeframe, TimeframeFeatures>>,

    // Raw Feature Set (for ML and complex Analysis)
    pub feature_set: Option<crate::domain::trading::types::FeatureSet>,
}

/// Signal generated by a trading strategy
#[derive(Debug, Clone, PartialEq)]
pub struct Signal {
    pub side: OrderSide,
    pub reason: String,
    pub confidence: f64, // 0.0 to 1.0
    pub suggested_stop_loss: Option<Decimal>,
    pub suggested_take_profit: Option<Decimal>,
}

impl Signal {
    pub fn buy(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Buy,
            reason: reason.into(),
            confidence: 1.0,
            suggested_stop_loss: None,
            suggested_take_profit: None,
        }
    }

    pub fn sell(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Sell,
            reason: reason.into(),
            confidence: 1.0,
            suggested_stop_loss: None,
            suggested_take_profit: None,
        }
    }

    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }

    pub fn with_stop_loss(mut self, stop_loss: Decimal) -> Self {
        self.suggested_stop_loss = Some(stop_loss);
        self
    }

    pub fn with_take_profit(mut self, take_profit: Decimal) -> Self {
        self.suggested_take_profit = Some(take_profit);
        self
    }
}

impl AnalysisContext {
    /// Check if a higher timeframe confirms the trend direction
    ///
    /// Returns true if the specified higher timeframe shows a trend aligned with the signal
    pub fn higher_timeframe_confirms_trend(&self, side: OrderSide, higher_tf: Timeframe) -> bool {
        let Some(ref tf_features) = self.timeframe_features else {
            // No multi-timeframe data available, default to true (backward compatible)
            return true;
        };

        let Some(features) = tf_features.get(&higher_tf) else {
            // Requested timeframe not available, default to true
            return true;
        };

        // Check if price is above/below trend SMA on higher timeframe
        match side {
            OrderSide::Buy => {
                // For buy signals, higher timeframe should be bullish (price > trend_sma)
                if let (Some(price), Some(trend_sma)) = (features.price, features.trend_sma) {
                    price > trend_sma
                } else {
                    true // Missing data, don't block
                }
            }
            OrderSide::Sell => {
                // For sell signals, we're more permissive
                true
            }
        }
    }

    /// Calculate multi-timeframe trend strength (0.0 to 1.0)
    ///
    /// Returns the percentage of timeframes showing bullish trend
    pub fn multi_timeframe_trend_strength(&self) -> Decimal {
        let Some(ref tf_features) = self.timeframe_features else {
            // No multi-timeframe data, use primary timeframe
            return if let Some(trend_sma) = self.trend_sma {
                if self.current_price > trend_sma {
                    Decimal::from(1)
                } else {
                    Decimal::from(0)
                }
            } else {
                Decimal::from(0) // No trend SMA available
            };
        };

        if tf_features.is_empty() {
            return if let Some(trend_sma) = self.trend_sma {
                if self.current_price > trend_sma {
                    Decimal::from(1)
                } else {
                    Decimal::from(0)
                }
            } else {
                Decimal::from(0)
            };
        }

        let mut bullish_count = 0;
        let mut total_count = 0;

        // Check primary timeframe
        if let Some(trend_sma) = self.trend_sma {
            if self.current_price > trend_sma {
                bullish_count += 1;
            }
            total_count += 1;
        }

        // Check each higher timeframe
        for features in tf_features.values() {
            if let (Some(price), Some(trend_sma)) = (features.price, features.trend_sma) {
                if price > trend_sma {
                    bullish_count += 1;
                }
                total_count += 1;
            }
        }

        if total_count == 0 {
            Decimal::ZERO
        } else {
            Decimal::from_f64(bullish_count as f64 / total_count as f64).unwrap_or(Decimal::ZERO)
        }
    }

    /// Check if all enabled timeframes show bullish trend
    pub fn all_timeframes_bullish(&self) -> bool {
        self.multi_timeframe_trend_strength() >= Decimal::ONE
    }

    /// Get ADX from highest available timeframe for regime detection
    pub fn get_highest_timeframe_adx(&self) -> Decimal {
        let Some(ref tf_features) = self.timeframe_features else {
            return self.adx.unwrap_or(Decimal::ZERO);
        };

        // Try to get ADX from highest timeframe (1Day > 4Hour > 1Hour > ...)
        for tf in [
            Timeframe::OneDay,
            Timeframe::FourHour,
            Timeframe::OneHour,
            Timeframe::FifteenMin,
        ] {
            if let Some(features) = tf_features.get(&tf)
                && let Some(adx) = features.adx
            {
                return adx;
            }
        }

        // Fall back to primary timeframe
        self.adx.unwrap_or(Decimal::ZERO)
    }
}

/// Trading strategy trait for the Strategy Pattern
pub trait TradingStrategy: Send + Sync {
    /// Analyze market context and potentially generate a trading signal
    fn analyze(&self, ctx: &AnalysisContext) -> Option<Signal>;

    /// Warmup the strategy (and internal models) with historical data
    /// Default implementation is a no-op which is fine for most stateless strategies
    fn warmup(&self, _ctx: &AnalysisContext) {}

    /// Strategy name for logging and identification
    fn name(&self) -> &str;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_creation() {
        let buy_signal = Signal::buy("Test reason");
        assert!(matches!(buy_signal.side, OrderSide::Buy));
        assert_eq!(buy_signal.confidence, 1.0);

        let sell_signal = Signal::sell("Another reason").with_confidence(0.8);
        assert!(matches!(sell_signal.side, OrderSide::Sell));
        assert_eq!(sell_signal.confidence, 0.8);
    }

    #[test]
    fn test_confidence_clamping() {
        let signal = Signal::buy("Test").with_confidence(1.5);
        assert_eq!(signal.confidence, 1.0);

        let signal2 = Signal::sell("Test").with_confidence(-0.5);
        assert_eq!(signal2.confidence, 0.0);
    }
}
