use crate::domain::types::OrderSide;
use rust_decimal::Decimal;

/// Context provided to trading strategies for analysis
#[derive(Debug, Clone)]
pub struct AnalysisContext {
    pub symbol: String,
    pub current_price: Decimal,
    pub price_f64: f64,

    // SMA state
    pub fast_sma: f64,
    pub slow_sma: f64,
    pub trend_sma: f64,

    // Technical indicators
    pub rsi: f64,
    pub macd_value: f64,
    pub macd_signal: f64,
    pub macd_histogram: f64,
    pub last_macd_histogram: Option<f64>,
    pub atr: f64,
    pub bb_lower: f64,
    pub bb_upper: f64,
    pub bb_middle: f64,

    // Position state
    pub has_position: bool,

    // Timestamp
    pub timestamp: i64,
}

/// Signal generated by a trading strategy
#[derive(Debug, Clone)]
pub struct Signal {
    pub side: OrderSide,
    pub reason: String,
    pub confidence: f64, // 0.0 to 1.0
}

impl Signal {
    pub fn buy(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Buy,
            reason: reason.into(),
            confidence: 1.0,
        }
    }

    pub fn sell(reason: impl Into<String>) -> Self {
        Self {
            side: OrderSide::Sell,
            reason: reason.into(),
            confidence: 1.0,
        }
    }

    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }
}

/// Trading strategy trait for the Strategy Pattern
pub trait TradingStrategy: Send + Sync {
    /// Analyze market context and potentially generate a trading signal
    fn analyze(&self, ctx: &AnalysisContext) -> Option<Signal>;

    /// Strategy name for logging and identification
    fn name(&self) -> &str;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_creation() {
        let buy_signal = Signal::buy("Test reason");
        assert!(matches!(buy_signal.side, OrderSide::Buy));
        assert_eq!(buy_signal.confidence, 1.0);

        let sell_signal = Signal::sell("Another reason").with_confidence(0.8);
        assert!(matches!(sell_signal.side, OrderSide::Sell));
        assert_eq!(sell_signal.confidence, 0.8);
    }

    #[test]
    fn test_confidence_clamping() {
        let signal = Signal::buy("Test").with_confidence(1.5);
        assert_eq!(signal.confidence, 1.0);

        let signal2 = Signal::sell("Test").with_confidence(-0.5);
        assert_eq!(signal2.confidence, 0.0);
    }
}
